<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>网络寻租</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="author" content="halida" />
    <link rel="alternate" type="application/rss+xml" title="网络寻租 - RSS" href="http://blog.linjunhalida.com/feed" />
    <link href="/stylesheets/pygments-default.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/site.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/jquery.js" type="text/javascript"></script>
  </head>
  <body class='color-4'>
    <div id='warper'>
      <nav>
        <div id='container'>
          <ul class='first-nav'>
            <li>
              <a href="/">网络寻租</a>
            </li>
            <li>
              <a href="/list.html">列表</a>
            </li>
            <li>
              <a href="/about.html">关于</a>
            </li>
          </ul>
          <ul class='secondary-nav'>
            <li>
              <a href="/feed.xml">feed</a>
            </li>
          </ul>
          <select id='color-select'>
            <option>1</option>
            <option>2</option>
            <option>3</option>
            <option>4</option>
            <option>5</option>
          </select>
        </div>
      </nav>
      <div id='block-nav'></div>
      <div id='content'>
        <div class='article'>
          <g:plusone></g:plusone>
          <script type='text/javascript'>
            //<![CDATA[
              window.___gcfg = {lang: 'zh-CN'};
              (function() {
                var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
                po.src = 'https://apis.google.com/js/plusone.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
              })();
            //]]>
          </script>
          <h1 class='article-title'>shpaml源码分析</h1>
          <div class="document">
          <p>在上次已经 <a class="reference external" href="http://server.linjunhalida.com/blog/article/shpaml%E4%BB%8B%E7%BB%8D/">介绍过shpaml</a>,
          它的代码总共只有365行, 既然这么一点代码, 没有理由不分析分析它的具体实现.</p>
          <p>首先, 代码可以在这里看到: <a class="reference external" href="http://shpaml.webfactional.com/source_code">http://shpaml.webfactional.com/source_code</a></p>
          <p>首先是入口出的代码:</p>
          <div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
              <span class="c"># if file name is given convert file, else convert stdin</span>
              <span class="kn">import</span> <span class="nn">sys</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                  <span class="n">shpaml_text</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
              <span class="k">else</span><span class="p">:</span>
                  <span class="n">shpaml_text</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
              <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">convert_text</span><span class="p">(</span><span class="n">shpaml_text</span><span class="p">))</span>
          </pre></div>
          <p>这里面是实现以下3种语法的功能, 太简单就不说了:</p>
          <blockquote>
          python -c &quot;import shpaml; shpaml.convert_text()&quot;
          echo 'b | foo' | python shpaml.py
          touch test.shpaml; python shpaml.py test.shpaml</blockquote>
          <p>然后, 从convert_text函数, 一直深入调用到了indent_lines函数(外面的几层都是包装), 这个才是重心.</p>
          <p>我们知道, html是树状的, 输入的shpaml格式的文档本质上也是树状的.
          我们需要把shpaml按照树状的方式解析出来, 同时对分析出来的数据做处理(加&lt;&gt;以及结尾加&lt;/tag&gt;).</p>
          <p>简单地介绍下代码里面的处理方式. 程序内嵌一个recurse函数, 这个函数的输入是字符串列表(就是需要转换的文本啦), 处理文本的时候如果发现有新的子树, 就会嵌套调用recurse, 用函数调用栈的方式来遍历tag树.
          每次处理文本, 都会把生成的文本放到output这个字符串列表里面去.
          下面是具体的代码:</p>
          <div class="highlight"><pre><span class="k">def</span> <span class="nf">indent_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span>
                      <span class="n">output</span><span class="p">,</span>
                      <span class="n">branch_method</span><span class="p">,</span>
                      <span class="n">leaf_method</span><span class="p">,</span>
                      <span class="n">pass_syntax</span><span class="p">,</span>
                      <span class="n">flush_left_syntax</span><span class="p">,</span>
                      <span class="n">flush_left_empty_line</span><span class="p">,</span>
                      <span class="n">indentation_method</span><span class="p">,</span>
                      <span class="n">get_block</span><span class="p">,</span>
                      <span class="p">):</span>
              <span class="sd">&quot;&quot;&quot;Returns None.</span>
          <span class="sd">    一堆注释不管它</span>
          <span class="sd">    &quot;&quot;&quot;</span>
              <span class="n">append</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">append</span>
              <span class="c"># 递归调用函数</span>
              <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">prefix_lines</span><span class="p">):</span>
                  <span class="c"># 循环解析传进来的字符串列表</span>
                  <span class="k">while</span> <span class="n">prefix_lines</span><span class="p">:</span>
                      <span class="c"># 列表已经处理过了, 分割成空格的前缀和后面的字符</span>
                      <span class="n">prefix</span><span class="p">,</span> <span class="n">line</span> <span class="o">=</span> <span class="n">prefix_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                      <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                          <span class="n">prefix_lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                          <span class="n">append</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
                          <span class="k">continue</span>
                      <span class="c"># 我们看看这一行是否有缩进</span>
                      <span class="n">block_size</span> <span class="o">=</span> <span class="n">get_block</span><span class="p">(</span><span class="n">prefix_lines</span><span class="p">)</span>
                      <span class="k">if</span> <span class="n">block_size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                          <span class="c"># 如果没有缩进, 就根据状况来处理</span>
                          <span class="n">prefix_lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="n">pass_syntax</span><span class="p">:</span>
                              <span class="k">pass</span>
                          <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">flush_left_syntax</span><span class="p">):</span>
                              <span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">flush_left_syntax</span><span class="p">):])</span>
                          <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">flush_left_empty_line</span><span class="p">):</span>
                              <span class="n">append</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
                          <span class="k">else</span><span class="p">:</span>
                              <span class="n">append</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">leaf_method</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                      <span class="k">else</span><span class="p">:</span>
                          <span class="c"># 如果是一个新的缩进, 我们需要找到缩进的结尾, 然后把这一块数据取出来,</span>
                          <span class="c"># 让branch_method处理下来</span>
                          <span class="n">block</span> <span class="o">=</span> <span class="n">prefix_lines</span><span class="p">[:</span><span class="n">block_size</span><span class="p">]</span>
                          <span class="n">prefix_lines</span> <span class="o">=</span> <span class="n">prefix_lines</span><span class="p">[</span><span class="n">block_size</span><span class="p">:]</span>
                          <span class="n">branch_method</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">recurse</span><span class="p">)</span>
                      <span class="c"># 循环消耗prefix_lines, 直到消耗完毕, 任务就完成了.</span>
                  <span class="k">return</span>
              <span class="n">prefix_lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">indentation_method</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span>
              <span class="n">recurse</span><span class="p">(</span><span class="n">prefix_lines</span><span class="p">)</span>
          </pre></div>
          <p>recurse 最后会进入到2个函数里面去, 一个是leaft_method, 它处理单行的一些语法, 比如: tag &gt; tag2 &gt; tag3 | text, 也是采用上面那种循环消耗字符串的方法. 这里略过不表.</p>
          <p>另一个就是branch_method, 这里面的值是函数html_block_tag. 它里面是处理缩进后的一些语法. 处理完头部之后, 会把缩进里面的内容传给recurse函数, 就这样一步步解析玩子树. 里面的append函数就把解析玩的内容传给output, 最后打印成html代码.</p>
          <div class="highlight"><pre><span class="k">def</span> <span class="nf">html_block_tag</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">recurse</span><span class="p">):</span>
              <span class="n">append</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">append</span>
              <span class="n">prefix</span><span class="p">,</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
              <span class="k">if</span> <span class="n">RAW_HTML</span><span class="o">.</span><span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
                  <span class="c"># 如果是html代码(&lt;开头)就不解析头部</span>
                  <span class="n">append</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">tag</span><span class="p">)</span>
                  <span class="c"># 解析子树</span>
                  <span class="n">recurse</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
              <span class="k">elif</span> <span class="n">COMMENT_SYNTAX</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
                  <span class="c"># 注释..</span>
                  <span class="k">pass</span>
              <span class="k">elif</span> <span class="n">VERBATIM_SYNTAX</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
                  <span class="c"># 子树不解析, 直接打印出来</span>
                  <span class="n">m</span> <span class="o">=</span> <span class="n">VERBATIM_SYNTAX</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                  <span class="n">tag</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                  <span class="n">start_tag</span><span class="p">,</span> <span class="n">end_tag</span> <span class="o">=</span> <span class="n">apply_jquery_sugar</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                  <span class="n">append</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">start_tag</span><span class="p">)</span>
                  <span class="n">stream</span><span class="p">(</span><span class="n">append</span><span class="p">,</span> <span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                  <span class="n">append</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">end_tag</span><span class="p">)</span>
              <span class="k">else</span><span class="p">:</span>
                  <span class="c"># 普通的状况, 解析出tag</span>
                  <span class="n">start_tag</span><span class="p">,</span> <span class="n">end_tag</span> <span class="o">=</span> <span class="n">apply_jquery_sugar</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                  <span class="c"># 输出tag头</span>
                  <span class="n">append</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">start_tag</span><span class="p">)</span>
                  <span class="c"># 解析子树</span>
                  <span class="n">recurse</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                  <span class="c"># 输出tag尾</span>
                  <span class="n">append</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">end_tag</span><span class="p">)</span>
          </pre></div>
          <div class="section" id="id1">
          <h1>结论</h1>
          <p>shpaml采用函数嵌套调用的方法来解析和处理树状结构, 这个也是通常用的解析树状结构的方法(如果树状结构嵌套不多的话), 对于编程语法的解析, 也可以采用类似这样的方式, 对于每一个语法规则都有一个函数, 然后嵌套调用解析, 直到解析完毕.</p>
          </div>
          </div>
        </div>
        <div class='time-stamp'>
          <p>建立时间: 2011/02/20 21:43:00</p>
          <p>更新时间: 2011/02/20 21:49:00</p>
        </div>
        <div id='comments'>
          <div id='disqus_thread'>
            <script type="text/javascript">
            (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://halidasvps.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=halidasvps">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
            <script type="text/javascript">
            var disqus_shortname = 'halidasvps';
            (function () {
            var s = document.createElement('script'); s.async = true;
            s.src = 'http://disqus.com/forums/halidasvps/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
            }());
            </script>
          </div>
        </div>
      </div>
      <footer>
        <p>
          @2011 linjunhalida, all right reserved,
          source code <a href="https://github.com/halida/haliblog" target="_blank">here</a>.
        </p>
      </footer>
    </div>
    <div id='return-top-block'>
      <div id='return-top-inner'>
        <a id='return-top' onclick="javascript: $('html,body').animate({scrollTop: 0}, 400);">===></a>
      </div>
    </div>
    <script src="/javascripts/jquery.pjax.js" type="text/javascript"></script>
    <script src="/javascripts/jquery.appear-1.1.1.min.js" type="text/javascript"></script>
    <script src="/javascripts/main.js" type="text/javascript"></script>
    <script src="/javascripts/vim.js" type="text/javascript"></script>
    <script type='text/javascript'>
      //<![CDATA[
        (function() {
    
      $(function() {
        init();
        return init_vim_key('#content');
      });
    
    }).call(this);
    
      //]]>
    </script>
    <script type='text/javascript'>
      //<![CDATA[
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-26509244-1']);
        _gaq.push(['_trackPageview', '_trackPageLoadTime']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      //]]>
    </script>
  </body>
</html>
